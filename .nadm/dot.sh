#!/usr/bin/env bash
set -euo pipefail

tracked_file="$HOME/.nadm/tracked"
gitignore_file="$HOME/.gitignore"

ensure_state() {
    mkdir -p "$HOME/.nadm"
    touch "$tracked_file"
}

canonicalize_path() {
    local input="$1"
    local raw="$input"
    local full_path
    local relative_path

    [[ -z "$raw" ]] && return 1

    if [[ "$raw" == "~/"* ]]; then
        raw="$HOME/${raw#~/}"
    elif [[ "$raw" != /* ]]; then
        raw="$PWD/$raw"
    fi

	full_path="$(realpath $raw)"

    case "$full_path" in
        "$HOME")
            relative_path="."
            ;;
        "$HOME"/*)
            relative_path="${full_path#"$HOME"/}"
            ;;
        *)
            printf 'Path must be inside %s: %s\n' "$HOME" "$input" >&2
            return 1
            ;;
    esac

    if [[ -d "$full_path" ]]; then
        printf '%s/\n' "${relative_path%/}"
    else
        printf '%s\n' "${relative_path%/}"
    fi
}

add_tracked_path() {
    local path="$1"

    if [[ ! -f "$tracked_file" ]] || ! grep -Fqx "$path" "$tracked_file"; then
        printf '%s\n' "$path" >> "$tracked_file"
    fi
}

forget_tracked_path() {
    local path="$1"
    local base_path="${path%/}"
    local temp_file

    temp_file="$(mktemp)"

    while IFS= read -r line || [[ -n "$line" ]]; do
        if [[ "$line" == "$base_path" || "$line" == "$base_path/" || "$line" == "$base_path/"* ]]; then
            continue
        fi

        printf '%s\n' "$line" >> "$temp_file"
    done < "$tracked_file"

    mv "$temp_file" "$tracked_file"
}

append_unique_line() {
    local output_file="$1"
    local value="$2"

    if [[ ! -f "$output_file" ]] || ! grep -Fqx "$value" "$output_file"; then
        printf '%s\n' "$value" >> "$output_file"
    fi
}

write_gitignore_header() {
    local output_file="$1"

    printf '%s\n' '# Do not edit this file directly.' > "$output_file"
    printf '%s\n' '# Edit ~/.nadm/tracked and run `jj dot sync`' >> "$output_file"
    printf '%s\n' '# Or, run `jj dot edit`' >> "$output_file"
    printf '\n' >> "$output_file"
    printf '%s\n' '*' >> "$output_file"
    printf '%s\n' '!/.gitignore' >> "$output_file"
}

append_unignore_rules_for_path() {
    local output_file="$1"
    local path="$2"
    local normalized_path="${path%/}"
    local is_directory="0"
    local prefix=""
    local index

    [[ -z "$normalized_path" ]] && return
    [[ "$normalized_path" == "." ]] && return

    if [[ "$path" == */ || -d "$HOME/$normalized_path" ]]; then
        is_directory="1"
    fi

    IFS='/' read -r -a path_parts <<< "$normalized_path"

    for (( index = 0; index < ${#path_parts[@]} - 1; index += 1 )); do
        if [[ -n "$prefix" ]]; then
            prefix="$prefix/${path_parts[$index]}"
        else
            prefix="${path_parts[$index]}"
        fi

        append_unique_line "$output_file" "!/$prefix/"
        append_unique_line "$output_file" "/$prefix/*"
    done

    if [[ "$is_directory" == "1" ]]; then
        append_unique_line "$output_file" "!/$normalized_path/"
        append_unique_line "$output_file" "!/$normalized_path/**"
    else
        append_unique_line "$output_file" "!/$normalized_path"
    fi
}

dot_sync() {
    local temp_file

    ensure_state
    temp_file="$(mktemp)"

    write_gitignore_header "$temp_file"

    while IFS= read -r path || [[ -n "$path" ]]; do
        [[ -z "$path" ]] && continue
        append_unignore_rules_for_path "$temp_file" "$path"
    done < "$tracked_file"

    mv "$temp_file" "$gitignore_file"
}

dot_add() {
    local target
    local canonical_path

    ensure_state

    if [[ $# -eq 0 ]]; then
        printf 'Usage: dot add <file-or-directory>...\n' >&2
        return 1
    fi

    for target in "$@"; do
        canonical_path="$(canonicalize_path "$target")"
        add_tracked_path "$canonical_path"
    done

    dot_sync
}

dot_forget() {
    local target
    local canonical_path

    ensure_state

    if [[ $# -eq 0 ]]; then
        printf 'Usage: dot forget <file-or-directory>...\n' >&2
        return 1
    fi

    for target in "$@"; do
        canonical_path="$(canonicalize_path "$target")"
        forget_tracked_path "$canonical_path"

		# TODO: It's a little inefficient to run a whole sync here, but
		# it's okay for now. dot_sync updates .gitignore, which is needed
		# or else jj will throw an error that the file is not ignored.
		dot_sync
        jj file untrack "${canonical_path%/}" || echo -e "\nAre you tracking a parent directory of ${canonical_path%/}?"
    done
}

dot_edit() {
	if [ -z "$EDITOR" ]; then
		echo '$EDITOR environmental variable not set'
		exit 1
	fi
	set -e
	$EDITOR ~/.nadm/tracked
	dot_sync
}

main() {
    local subcommand="${1:-}"

    case "$subcommand" in
        add)
            shift
            dot_add "$@"
            ;;
        forget)
            shift
            dot_forget "$@"
            ;;
        sync)
            dot_sync
            ;;
        edit)
            dot_edit
            ;;
        *)
            printf 'Usage: dot <add|forget|edit|sync> [paths...]\n' >&2
            return 1
            ;;
    esac
}

main "$@"
